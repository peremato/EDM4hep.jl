var documenterSearchIndex = {"docs":
[{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/#1.0.0-(WIP)","page":"Release Notes","title":"1.0.0 (WIP)","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"New EDM4hep schema version 1 not backward compatible\nRelation between ReconstructedParticle to `ParticleID inverted\nNames and comments of attributes have been revised\nLink entities are now implemented using a parametric type Link{FROM,TO}\nIntroduced GeneratorEventParameters for MC generators covMatrix::CovMatrix2f           #  covariance matrix of the charge and time measurements \nNew types for covariant matrices (e.g. CovMatrix2f)\nIntroduced type interfaces (e.g. TrackerHit) that types can inherit from (e.g. TrackerHit3D)\nIntroduced EDCollection{ED} to represent a collection of data of a given EDM4hep type. It is always implemented as a StructArray type to provide an effcient \"SoA\" access to the data. Added, as well, a few functions to provide an iterable and indexing behavior to the collections, and to control their lifetime (e.g. getEDCollection, hasEDCollection, initEDCollection, emptyEDStore). It replaces EDStore type and their functions.\nAdded more tests, in particular reading files exercising all defined types and their relations.\nAdded two new tutorials as part of the generated documentation. One to exercise the EDM4hep model (EDM), and one for reading ROOT data file (I/O).","category":"page"},{"location":"release_notes/#0.4.2","page":"Release Notes","title":"0.4.2","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Moved to JuliaHEP organization\nUpdate to FHist 0.11 series (#9)","category":"page"},{"location":"release_notes/#0.4.1","page":"Release Notes","title":"0.4.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Use StructArrays also for EDStore when building the model directly in memory.","category":"page"},{"location":"release_notes/#0.4.0","page":"Release Notes","title":"0.4.0","text":"","category":"section"},{"location":"release_notes/#New-Functionality","page":"Release Notes","title":"New Functionality","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Added function RootIO.create_getter(reader::Reader, bname::String; selection=nothing) to create a getter function for a specific branch. The optional argument allows to select leaves to be read.\nThe overall performance is highly improved (factor 3 with respect previous version)","category":"page"},{"location":"release_notes/#0.3.1","page":"Release Notes","title":"0.3.1","text":"","category":"section"},{"location":"release_notes/#Bug-Fixes","page":"Release Notes","title":"Bug Fixes","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Legacy podio test fixed","category":"page"},{"location":"release_notes/#0.3.0","page":"Release Notes","title":"0.3.0","text":"","category":"section"},{"location":"release_notes/#New-Functionality-2","page":"Release Notes","title":"New Functionality","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Optimisations by explicitly generation of StructArrays\nSupport for multi-files\nSupport for multi-threading\nSupport for RNTuple RC2\nAdded analysis module ROOT.Analysis (mini-framework for MT analysis)","category":"page"},{"location":"release_notes/#0.2.0","page":"Release Notes","title":"0.2.0","text":"","category":"section"},{"location":"release_notes/#New-Functionality-3","page":"Release Notes","title":"New Functionality","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Added support for older versions of PODIO file formats\nAdded analysis example for FCCAnalysis","category":"page"},{"location":"release_notes/#0.1.0","page":"Release Notes","title":"0.1.0","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"First release. It provides the basic functionality to create in memory an event model and be able to read from a ROOT file (supporting both TTree and RNTuple formats).","category":"page"},{"location":"api/#Public-Documentation","page":"Public APIs","title":"Public Documentation","text":"","category":"section"},{"location":"api/","page":"Public APIs","title":"Public APIs","text":"Documentation for EDM4hep.jl public interface.","category":"page"},{"location":"api/#Index-Types","page":"Public APIs","title":"Index - Types","text":"","category":"section"},{"location":"api/","page":"Public APIs","title":"Public APIs","text":"Pages   = [\"api.md\"]\nModules = [EDM4hep, EDM4hep.RootIO, EDM4hep.Histograms, EDM4hep.Analysis]\nOrder   = [:type]","category":"page"},{"location":"api/#Index-Functions","page":"Public APIs","title":"Index - Functions","text":"","category":"section"},{"location":"api/","page":"Public APIs","title":"Public APIs","text":"Pages   = [\"api.md\"]\nModules = [EDM4hep, EDM4hep.RootIO, EDM4hep.Histograms, EDM4hep.Analysis]\nOrder   = [:function]","category":"page"},{"location":"api/#Modules","page":"Public APIs","title":"Modules","text":"","category":"section"},{"location":"api/","page":"Public APIs","title":"Public APIs","text":"Modules = [EDM4hep, EDM4hep.RootIO, EDM4hep.Analysis]\nOrder = [:module]","category":"page"},{"location":"api/#EDM4hep.EDM4hep","page":"Public APIs","title":"EDM4hep.EDM4hep","text":"Main module for EDM4hep.jl – Key4hep Event Data Model for Julia.\n\nAll data model types are exported from this module for public use\n\nExports\n\n\n\n\n\n","category":"module"},{"location":"api/#EDM4hep.RootIO","page":"Public APIs","title":"EDM4hep.RootIO","text":"ROOT I/O module for EDM4hep.jl\n\nIt supports both formats: TTree and RNTuple\n\n\n\n\n\n","category":"module"},{"location":"api/#EDM4hep.Analysis","page":"Public APIs","title":"EDM4hep.Analysis","text":"Analysis module for EDM4hep.jl\n\nA number of data structures and functions to support analysis of EDM4hep data in multithreaded mode.\n\n\n\n\n\n","category":"module"},{"location":"api/#Types","page":"Public APIs","title":"Types","text":"","category":"section"},{"location":"api/","page":"Public APIs","title":"Public APIs","text":"This is the list of all types defined for EDM4hep using the PODIO yaml file.","category":"page"},{"location":"api/","page":"Public APIs","title":"Public APIs","text":"Modules = [EDM4hep, EDM4hep.RootIO, EDM4hep.Histograms, EDM4hep.Analysis]\nOrder = [:type]","category":"page"},{"location":"api/#EDM4hep.CaloHitContribution","page":"Public APIs","title":"EDM4hep.CaloHitContribution","text":"Monte Carlo contribution to SimCalorimeterHit\n\nAuthor: EDM4hep authors\n\nFields\n\nPDG::Int32:  PDG code of the shower particle that caused this contribution \nenergy::Float32:  energy of the this contribution [G]\ntime::Float32:  time of this contribution [ns]\nstepPosition::Vector3f:  position of this energy deposition (step) [mm]\n\nRelations\n\nparticle::MCParticle:  primary MCParticle that caused the shower responsible for this contribution to the hit \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.CalorimeterHit","page":"Public APIs","title":"EDM4hep.CalorimeterHit","text":"Calorimeter hit\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  detector specific (geometrical) cell id \nenergy::Float32:  energy of the hit [GeV]\nenergyError::Float32:  error of the hit energy [GeV]\ntime::Float32:  time of the hit [ns]\nposition::Vector3f:  position of the hit in world coordinates [mm]\ntype::Int32:  type of hit \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Cluster","page":"Public APIs","title":"EDM4hep.Cluster","text":"Calorimeter Hit Cluster\n\nAuthor: EDM4hep authors\n\nFields\n\ntype::Int32:  flagword that defines the type of cluster \nenergy::Float32:  energy of the cluster [GeV]\nenergyError::Float32:  error on the energy [GeV]\nposition::Vector3f:  position of the cluster [mm]\npositionError::CovMatrix3f:  covariance matrix of the position \niTheta::Float32:  intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP \nphi::Float32:  intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP \ndirectionError::Vector3f:  covariance matrix of the direction [mm**2]\nshapeParameters::PVector{Float32}:  shape parameters. This should be accompanied by a descriptive list of names in the shapeParameterNames collection level metadata, as a vector of strings with the same ordering \nsubdetectorEnergies::PVector{Float32}:  energy observed in a particular subdetector \n\nRelations\n\nclusters::Cluster:  clusters that have been combined to this cluster \nhits::CalorimeterHit:  hits that have been combined to this cluster \n\nMethods\n\nsetShapeParameters(object::Cluster, v::AbstractVector{Float32}): assign a set of values to the shapeParameters vector member\nsetSubdetectorEnergies(object::Cluster, v::AbstractVector{Float32}): assign a set of values to the subdetectorEnergies vector member\npushToClusters(obj::Cluster, robj::Cluster): push related object to the clusters relation\npopFromClusters(obj::Cluster): pop last related object from clusters relation\npushToHits(obj::Cluster, robj::CalorimeterHit): push related object to the hits relation\npopFromHits(obj::Cluster): pop last related object from hits relation\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.CovMatrix2f","page":"Public APIs","title":"EDM4hep.CovMatrix2f","text":"A generic 2 dimensional covariance matrix with values stored in lower triangular form\n\nFields\n\nvalues::SVector{3,Float32}:  the covariance matrix values \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.CovMatrix3f","page":"Public APIs","title":"EDM4hep.CovMatrix3f","text":"A generic 3 dimensional covariance matrix with values stored in lower triangular form\n\nFields\n\nvalues::SVector{6,Float32}:  the covariance matrix values \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.CovMatrix4f","page":"Public APIs","title":"EDM4hep.CovMatrix4f","text":"A generic 4 dimensional covariance matrix with values stored in lower triangular form\n\nFields\n\nvalues::SVector{10,Float32}:  the covariance matrix values \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.CovMatrix6f","page":"Public APIs","title":"EDM4hep.CovMatrix6f","text":"A generic 6 dimensional covariance matrix with values stored in lower triangular form\n\nFields\n\nvalues::SVector{21,Float32}:  the covariance matrix values \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.EDCollection","page":"Public APIs","title":"EDM4hep.EDCollection","text":"EDCollection{ED} where ED <: POD\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.EventHeader","page":"Public APIs","title":"EDM4hep.EventHeader","text":"Event Header. Additional parameters are assumed to go into the metadata tree.\n\nAuthor: EDM4hep authors\n\nFields\n\neventNumber::Int32:  event number \nrunNumber::Int32:  run number \ntimeStamp::UInt64:  time stamp \nweight::Float64:  event weight \nweights::PVector{Float64}:  event weights in case there are multiple. NOTE that weights[0] might not be the same as weight! Event weight names should be stored using the edm4hep::EventWeights name in the file level metadata \n\nMethods\n\nsetWeights(object::EventHeader, v::AbstractVector{Float64}): assign a set of values to the weights vector member\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.GeneratorEventParameters","page":"Public APIs","title":"EDM4hep.GeneratorEventParameters","text":"Generator event parameters\n\nAuthor: EDM4hep authors\n\nFields\n\neventScale::Float64:  event scale \nalphaQED::Float64:  alpha_QED \nalphaQCD::Float64:  alpha_QCD \nsignalProcessId::Int32:  id of signal process \nsqrts::Float64:  sqrt(s) [GeV]\ncrossSections::PVector{Float64}:  list of cross sections [pb]\ncrossSectionErrors::PVector{Float64}:  list of cross section errors [pb]\n\nRelations\n\nsignalVertex::MCParticle:  List of initial state MCParticle that are the source of the hard interaction \n\nMethods\n\nsetCrossSections(object::GeneratorEventParameters, v::AbstractVector{Float64}): assign a set of values to the crossSections vector member\nsetCrossSectionErrors(object::GeneratorEventParameters, v::AbstractVector{Float64}): assign a set of values to the crossSectionErrors vector member\npushToSignalVertex(obj::GeneratorEventParameters, robj::MCParticle): push related object to the signalVertex relation\npopFromSignalVertex(obj::GeneratorEventParameters): pop last related object from signalVertex relation\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.GeneratorPdfInfo","page":"Public APIs","title":"EDM4hep.GeneratorPdfInfo","text":"Generator pdf information\n\nAuthor: EDM4hep authors\n\nFields\n\npartonId::SVector{2,Int32}:  Parton PDG id \nlhapdfId::SVector{2,Int32}:  LHAPDF PDF id (see https://lhapdf.hepforge.org/pdfsets.html) \nx::SVector{2,Float64}:  Parton momentum fraction \nxf::SVector{2,Float64}:  PDF value \nscale::Float64:  Factorisation scale [GeV]\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.MCParticle","page":"Public APIs","title":"EDM4hep.MCParticle","text":"The Monte Carlo particle - based on the lcio::MCParticle.\n\nAuthor: EDM4hep authors\n\nFields\n\nPDG::Int32:  PDG code of the particle \ngeneratorStatus::Int32:  status of the particle as defined by the generator \nsimulatorStatus::Int32:  status of the particle from the simulation program - use BIT constants below \ncharge::Float32:  particle charge \ntime::Float32:  creation time of the particle in wrt. the event, e.g. for preassigned decays or decays in flight from the simulator [ns]\nmass::Float64:  mass of the particle [GeV]\nvertex::Vector3d:  production vertex of the particle [mm]\nendpoint::Vector3d:  endpoint of the particle [mm]\nmomentum::Vector3d:  particle 3-momentum at the production vertex [GeV]\nmomentumAtEndpoint::Vector3d:  particle 3-momentum at the endpoint [GeV]\nspin::Vector3f:  spin (helicity) vector of the particle \ncolorFlow::Vector2i:  color flow as defined by the generator \n\nRelations\n\nparents::MCParticle:  The parents of this particle \ndaughters::MCParticle:  The daughters this particle \n\nMethods\n\npushToParents(obj::MCParticle, robj::MCParticle): push related object to the parents relation\npopFromParents(obj::MCParticle): pop last related object from parents relation\npushToDaughters(obj::MCParticle, robj::MCParticle): push related object to the daughters relation\npopFromDaughters(obj::MCParticle): pop last related object from daughters relation\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.ParticleID","page":"Public APIs","title":"EDM4hep.ParticleID","text":"ParticleID\n\nAuthor: EDM4hep authors\n\nFields\n\ntype::Int32:  userdefined type \nPDG::Int32:  PDG code of this id - ( 999999 ) if unknown \nalgorithmType::Int32:  type of the algorithm/module that created this hypothesis \nlikelihood::Float32:  likelihood of this hypothesis - in a user defined normalization \nparameters::PVector{Float32}:  parameters associated with this hypothesis \n\nRelations\n\nparticle::ReconstructedParticle:  the particle from which this PID has been computed \n\nMethods\n\nsetParameters(object::ParticleID, v::AbstractVector{Float32}): assign a set of values to the parameters vector member\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Quantity","page":"Public APIs","title":"EDM4hep.Quantity","text":"Quantity\n\nFields\n\ntype::Int16:  flag identifying how to interpret the quantity \nvalue::Float32:  value of the quantity \nerror::Float32:  error on the value of the quantity \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.RawCalorimeterHit","page":"Public APIs","title":"EDM4hep.RawCalorimeterHit","text":"Raw calorimeter hit\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  detector specific (geometrical) cell id \namplitude::Int32:  amplitude of the hit in ADC counts \ntimeStamp::Int32:  time stamp for the hit \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.RawTimeSeries","page":"Public APIs","title":"EDM4hep.RawTimeSeries","text":"Raw data of a detector readout\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  detector specific cell id \nquality::Int32:  quality flag for the hit \ntime::Float32:  time of the hit [ns]\ncharge::Float32:  integrated charge of the hit [fC]\ninterval::Float32:  interval of each sampling [ns]\nadcCounts::PVector{Int32}:  raw data (32-bit) word at i \n\nMethods\n\nsetAdcCounts(object::RawTimeSeries, v::AbstractVector{Int32}): assign a set of values to the adcCounts vector member\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.RecDqdx","page":"Public APIs","title":"EDM4hep.RecDqdx","text":"dN/dx or dE/dx info of a Track\n\nAuthor: EDM4hep authors\n\nFields\n\ndQdx::Quantity:  the reconstructed dEdx or dNdx and its error \n\nRelations\n\ntrack::Track:  the corresponding track \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.ReconstructedParticle","page":"Public APIs","title":"EDM4hep.ReconstructedParticle","text":"Reconstructed Particle\n\nAuthor: EDM4hep authors\n\nFields\n\nPDG::Int32:  PDG of the reconstructed particle. \nenergy::Float32:  energy of the reconstructed particle. Four momentum state is not kept consistent internally [GeV]\nmomentum::Vector3f:   particle momentum. Four momentum state is not kept consistent internally [GeV]\nreferencePoint::Vector3f:  reference, i.e. where the particle has been measured [mm]\ncharge::Float32:  charge of the reconstructed particle \nmass::Float32:   mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally [GeV]\ngoodnessOfPID::Float32:  overall goodness of the PID on a scale of [0;1] \ncovMatrix::CovMatrix4f:  covariance matrix of the reconstructed particle 4vector \n\nRelations\n\ndecayVertex::Vertex:  decay vertex for the particle (if it is a composite particle) \nclusters::Cluster:  clusters that have been used for this particle \ntracks::Track:  tracks that have been used for this particle \nparticles::ReconstructedParticle:  reconstructed particles that have been combined to this particle \n\nMethods\n\npushToClusters(obj::ReconstructedParticle, robj::Cluster): push related object to the clusters relation\npopFromClusters(obj::ReconstructedParticle): pop last related object from clusters relation\npushToTracks(obj::ReconstructedParticle, robj::Track): push related object to the tracks relation\npopFromTracks(obj::ReconstructedParticle): pop last related object from tracks relation\npushToParticles(obj::ReconstructedParticle, robj::ReconstructedParticle): push related object to the particles relation\npopFromParticles(obj::ReconstructedParticle): pop last related object from particles relation\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.SimCalorimeterHit","page":"Public APIs","title":"EDM4hep.SimCalorimeterHit","text":"Simulated calorimeter hit\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  ID of the sensor that created this hit \nenergy::Float32:  energy of the hit [GeV]\nposition::Vector3f:  position of the hit in world coordinates [mm]\n\nRelations\n\ncontributions::CaloHitContribution:  Monte Carlo step contributions \n\nMethods\n\npushToContributions(obj::SimCalorimeterHit, robj::CaloHitContribution): push related object to the contributions relation\npopFromContributions(obj::SimCalorimeterHit): pop last related object from contributions relation\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.SimTrackerHit","page":"Public APIs","title":"EDM4hep.SimTrackerHit","text":"Simulated tracker hit\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  ID of the sensor that created this hit \neDep::Float32:  energy deposited in the hit [GeV]\ntime::Float32:  proper time of the hit in the lab frame [ns]\npathLength::Float32:  path length of the particle in the sensitive material that resulted in this hit \nquality::Int32:  quality bit flag \nposition::Vector3d:  the hit position [mm]\nmomentum::Vector3f:  the 3-momentum of the particle at the hits position [GeV]\n\nRelations\n\nparticle::MCParticle:  MCParticle that caused the hit \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.TimeSeries","page":"Public APIs","title":"EDM4hep.TimeSeries","text":"Calibrated Detector Data\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  cell id \ntime::Float32:  begin time [ns]\ninterval::Float32:  interval of each sampling [ns]\namplitude::PVector{Float32}:  calibrated detector data \n\nMethods\n\nsetAmplitude(object::TimeSeries, v::AbstractVector{Float32}): assign a set of values to the amplitude vector member\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Track","page":"Public APIs","title":"EDM4hep.Track","text":"Reconstructed track\n\nAuthor: EDM4hep authors\n\nFields\n\ntype::Int32:  flagword that defines the type of track \nchi2::Float32:  Chi^2 of the track fit \nndf::Int32:  number of degrees of freedom of the track fit \nNholes::Int32:  number of holes on track \nsubdetectorHitNumbers::PVector{Int32}:  number of hits in particular subdetectors \nsubdetectorHoleNumbers::PVector{Int32}:  number of holes in particular subdetectors \ntrackStates::PVector{TrackState}:  track states \n\nRelations\n\ntrackerHits::TrackerHit:  hits that have been used to create this track \ntracks::Track:  tracks (segments) that have been combined to create this track \n\nMethods\n\nsetSubdetectorHitNumbers(object::Track, v::AbstractVector{Int32}): assign a set of values to the subdetectorHitNumbers vector member\nsetSubdetectorHoleNumbers(object::Track, v::AbstractVector{Int32}): assign a set of values to the subdetectorHoleNumbers vector member\nsetTrackStates(object::Track, v::AbstractVector{TrackState}): assign a set of values to the trackStates vector member\npushToTrackerHits(obj::Track, robj::TrackerHit): push related object to the trackerHits relation\npopFromTrackerHits(obj::Track): pop last related object from trackerHits relation\npushToTracks(obj::Track, robj::Track): push related object to the tracks relation\npopFromTracks(obj::Track): pop last related object from tracks relation\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.TrackState","page":"Public APIs","title":"EDM4hep.TrackState","text":"Parametrized description of a particle track\n\nFields\n\nlocation::Int32:  for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation \nD0::Float32:  transverse impact parameter \nphi::Float32:  azimuthal angle \nomega::Float32:  is the signed curvature of the track [1/mm]\nZ0::Float32:  longitudinal impact parameter \ntanLambda::Float32:  lambda is the dip angle of the track in r-z \ntime::Float32:  time of the track at this trackstate [ns]\nreferencePoint::Vector3f:  Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter [mm]\ncovMatrix::CovMatrix6f:  covariance matrix of the track parameters. \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.TrackerHit","page":"Public APIs","title":"EDM4hep.TrackerHit","text":"Tracker hit interface class\n\nAuthor: Thomas Madlener, DESY\n\nFields\n\ncellID::UInt64:  ID of the sensor that created this hit \ntype::Int32:  type of the raw data hit \nquality::Int32:  quality bit flag of the hit \ntime::Float32:  time of the hit [ns]\neDep::Float32:  energy deposited on the hit [GeV]\neDepError::Float32:  error measured on eDep [GeV]\nposition::Vector3d:  hit position [mm]\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.TrackerHit3D","page":"Public APIs","title":"EDM4hep.TrackerHit3D","text":"Tracker hit\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  ID of the sensor that created this hit \ntype::Int32:  type of raw data hit \nquality::Int32:  quality bit flag of the hit \ntime::Float32:  time of the hit [ns]\neDep::Float32:  energy deposited on the hit [GeV]\neDepError::Float32:  error measured on EDep [GeV]\nposition::Vector3d:  hit position [mm]\ncovMatrix::CovMatrix3f:  covariance matrix of the position (x,y,z) \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.TrackerHitPlane","page":"Public APIs","title":"EDM4hep.TrackerHitPlane","text":"Tracker hit plane\n\nAuthor: EDM4hep authors\n\nFields\n\ncellID::UInt64:  ID of the sensor that created this hit \ntype::Int32:  type of raw data hit \nquality::Int32:  quality bit flag of the hit \ntime::Float32:  time of the hit [ns]\neDep::Float32:  energy deposited on the hit [GeV]\neDepError::Float32:  error measured on EDep [GeV]\nu::Vector2f:  measurement direction vector, u lies in the x-y plane \nv::Vector2f:  measurement direction vector, v is along z \ndu::Float32:  measurement error along the direction \ndv::Float32:  measurement error along the direction \nposition::Vector3d:  hit position [mm]\ncovMatrix::CovMatrix3f:  covariance of the position (x,y,z) \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Vector2f","page":"Public APIs","title":"EDM4hep.Vector2f","text":"Vector2f\n\nFields\n\na::Float32: \nb::Float32: \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Vector2i","page":"Public APIs","title":"EDM4hep.Vector2i","text":"Vector2i\n\nFields\n\na::Int32: \nb::Int32: \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Vector3d","page":"Public APIs","title":"EDM4hep.Vector3d","text":"Vector3d\n\nFields\n\nx::Float64: \ny::Float64: \nz::Float64: \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Vector3f","page":"Public APIs","title":"EDM4hep.Vector3f","text":"Vector3f\n\nFields\n\nx::Float32: \ny::Float32: \nz::Float32: \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Vector4f","page":"Public APIs","title":"EDM4hep.Vector4f","text":"Generic vector for storing classical 4D coordinates in memory. Four momentum helper functions are in edm4hep::utils\n\nFields\n\nx::Float32: \ny::Float32: \nz::Float32: \nt::Float32: \n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Vertex","page":"Public APIs","title":"EDM4hep.Vertex","text":"Vertex\n\nAuthor: EDM4hep authors\n\nFields\n\ntype::UInt32:  Flagword that defines the type of the vertex, see reserved bits for more information \nchi2::Float32:  chi-squared of the vertex fit \nndf::Int32:  number of degrees of freedom of the vertex fit \nposition::Vector3f:  [mm] position of the vertex \ncovMatrix::CovMatrix3f:  covariance matrix of the position \nalgorithmType::Int32:  type code for the algorithm that has been used to create the vertex \nparameters::PVector{Float32}:  additional parameters related to this vertex \n\nRelations\n\nparticles::POD:  particles that have been used to form this vertex, aka the decay particles emerging from this vertex \n\nMethods\n\nsetParameters(object::Vertex, v::AbstractVector{Float32}): assign a set of values to the parameters vector member\npushToParticles(obj::Vertex, robj::POD): push related object to the particles relation\npopFromParticles(obj::Vertex): pop last related object from particles relation\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.RootIO.Reader","page":"Public APIs","title":"EDM4hep.RootIO.Reader","text":"The Reader structure keeps a reference to the UnROOT LazyTree and caches already built 'layouts' of the EDM4hep types. The layouts maps a set of columns in the LazyTree into an object.\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Histograms.H1D","page":"Public APIs","title":"EDM4hep.Histograms.H1D","text":"H1D(title::String, nbins::Int, min::Float, max::Float, unit::Symbol)     Create a 1-dimensional histogram carrying the title and units.\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Histograms.H2D","page":"Public APIs","title":"EDM4hep.Histograms.H2D","text":"H2D(title::String, xbins::Int, xmin::Float, xmax::Float, ybins::Int, ymin::Float, ymax::Float, unit::Tuple{Symbol,Symbol})     Create a 2-dimensional histogram carrying the title and units.\n\n\n\n\n\n","category":"type"},{"location":"api/#EDM4hep.Histograms.H3D","page":"Public APIs","title":"EDM4hep.Histograms.H3D","text":"H3D(title::String, xbins::Int, xmin::Float, xmax::Float, ybins::Int, ymin::Float, ymax::Float, zbins::Int, zmin::Float, zmax::Float, unit::Tuple{Symbol,Symbol,Symbol})     Create a 2-dimensional histogram carrying the title and units.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"Public APIs","title":"Functions","text":"","category":"section"},{"location":"api/","page":"Public APIs","title":"Public APIs","text":"Modules = [EDM4hep, EDM4hep.RootIO, EDM4hep.Histograms, EDM4hep.Analysis]\nOrder = [:function]","category":"page"},{"location":"api/#EDM4hep.emptyEDStore-Tuple{}","page":"Public APIs","title":"EDM4hep.emptyEDStore","text":"emptyEDStore()\n\nEmpty the whole store.\n\n\n\n\n\n","category":"method"},{"location":"api/#EDM4hep.getEDCollection-Union{Tuple{Type{ED}}, Tuple{ED}, Tuple{Type{ED}, UInt32}} where ED","page":"Public APIs","title":"EDM4hep.getEDCollection","text":"getEDCollection(::Type{ED}, collid::UInt32=0x00000000)\n\nGet the store corresponding to the collid. If it is not specified then obtain a collid from the data type ED.\n\n\n\n\n\n","category":"method"},{"location":"api/#EDM4hep.hasEDCollection-Tuple{UInt32}","page":"Public APIs","title":"EDM4hep.hasEDCollection","text":"hasEDCollection(collid::UInt32)\n\nFind out if the store with collid is there.\n\n\n\n\n\n","category":"method"},{"location":"api/#EDM4hep.initEDCollection-Union{Tuple{Type{ED}}, Tuple{ED}} where ED","page":"Public APIs","title":"EDM4hep.initEDCollection","text":"initEDCollection(::Type{ED}) where ED\n\nInitialize the store corresponding to type ED.\n\n\n\n\n\n","category":"method"},{"location":"api/#EDM4hep.RootIO.create_getter-Tuple{EDM4hep.RootIO.Reader, String}","page":"Public APIs","title":"EDM4hep.RootIO.create_getter","text":"create_getter(reader::Reader, bname::String; selection=nothing)\n\nThis function creates a getter function for a given branch name. The getter function is a function that takes an event and returns a StructArray with the data of the branch. The getter function is created as a function with the name get_<branchname>. The optional parameter selection is a list of field names to be selected from the branch. If selection is not provided, all fields are selected. The user can use a list of strings, symbols or regular expressions to select the fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#EDM4hep.RootIO.get-Tuple{EDM4hep.RootIO.Reader, String}","page":"Public APIs","title":"EDM4hep.RootIO.get","text":"get(reader::Reader, treename::String)\n\nOpens a 'TTree' or 'RNTuple' in the ROOT file (typically the events tree).  It returns a 'LazyTree' that allows the user to iterate over events. \n\n\n\n\n\n","category":"method"},{"location":"api/#EDM4hep.RootIO.get-Tuple{EDM4hep.RootIO.Reader, UnROOT.LazyEvent, String}","page":"Public APIs","title":"EDM4hep.RootIO.get","text":"get(reader::Reader, evt::UnROOT.LazyEvent, bname::String; btype::Type=Any, register=true)\n\nGets an object collection by its name, with the possibility to overwrite the mapping Julia type or use the  type known in the ROOT file (C++ class name). The optional key parameter register indicates if the collection needs to be registered to the EDStore.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.append!-Tuple{EDM4hep.Analysis.AbstractAnalysisData, EDM4hep.Analysis.AbstractAnalysisData}","page":"Public APIs","title":"Base.append!","text":"Base.append!(d1::AbstractAnalysisData, d2::AbstractAnalysisData)\n\nDefault function to reset the user analysis data structure in case it  is not provided explicitly.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.empty!-Tuple{EDM4hep.Analysis.AbstractAnalysisData}","page":"Public APIs","title":"Base.empty!","text":"Base.empty!(data::AbstractAnalysisData)\n\nDefault function to reset the user analysis data structure in case it  is not provided explicitly.\n\n\n\n\n\n","category":"method"},{"location":"api/#EDM4hep.Analysis.do_analysis!-Tuple{EDM4hep.Analysis.AbstractAnalysisData, Any, Any, Any}","page":"Public APIs","title":"EDM4hep.Analysis.do_analysis!","text":"doanalysis!(data::AbstractAnalysisData, analysis, reader, events; mt::Bool=false, tasksper_thread::Int=4)\n\nPerform an analysis on all events by executing the analysis function.  The iteration will be chunked and distributed to different tasks running on  different threads if the option argument mt is set to true.  The results in data for all the chunks will be merged at the end of the analysis.   \n\n\n\n\n\n","category":"method"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"EditURL = \"tutorial_edm_lit.jl\"","category":"page"},{"location":"tutorial_edm/#EDM4hep.jl-EDM-Tutorial","page":"Tutorial (EDM)","title":"EDM4hep.jl EDM Tutorial","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"This tutorial shows how to use the EDM4hep Julia types to create data models in memory.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"note: Note that\nYou can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial_edm/#Table-of-contents","page":"Tutorial (EDM)","title":"Table of contents","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Pages = [\"tutorial_edm.md\"]\nDepth = 2:3","category":"page"},{"location":"tutorial_edm/#Loading-the-necessary-modules","page":"Tutorial (EDM)","title":"Loading the necessary modules","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"We will use the EDM4hep module that defines all the EDM4hep types and its relations and links.\nWe will use the PYTHIA8 module to generate realistic MC Particles\nWe will use the Corpuscles module to access the properties of the particles\nWe will use the FHist module to create histograms\nWe will use the Plots module to plot the histograms","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"If these modules are not installed, you can install them by running the following commands:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"using Pkg\nPkg.add(\"EDM4hep\")\nPkg.add(\"PYTHIA8\")\nPkg.add(\"FHist\")\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"using EDM4hep\nusing PYTHIA8\nusing Corpuscles: hascharm, hasstrange, ismeson, isbaryon\nusing FHist\nusing Plots: plot, plot!, theme\nimport DisplayAs: PNG #hide","category":"page"},{"location":"tutorial_edm/#Create-a-collection-of-MCParticles-in-memory","page":"Tutorial (EDM)","title":"Create a collection of MCParticles in memory","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"We will create a collection of MCParticles explicitly","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"p1 = MCParticle(PDG=2212, mass=0.938, momentum=(0.0, 0.0, 7000.0), generatorStatus=3);\np2 = MCParticle(PDG=2212, mass=0.938, momentum=(0.0, 0.0, -7000.0), generatorStatus=3);\nnothing #hide","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The particles p1 and p2 are the initial protons in the event.","category":"page"},{"location":"tutorial_edm/#Accessing-the-properties-of-the-MCParticles","page":"Tutorial (EDM)","title":"Accessing the properties of the MCParticles","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"You can access the properties of the particles as follows:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"println(\"Particle p1 has PDG=$(p1.PDG), mass=$(p1.mass), momentum=$(p1.momentum), and generatorStatus=$(p1.generatorStatus)\")\nprintln(\"Particle p2 has PDG=$(p2.PDG), mass=$(p2.mass), momentum=$(p2.momentum), and generatorStatus=$(p2.generatorStatus)\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The names of the particles can be accessed using the name property (added to MCParticle)","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"println(\"Particle p1 has name=$(p1.name)\")\nprintln(\"Particle p2 has name=$(p2.name)\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The energy of the particles can be accessed using the energy property (added to MCParticle)","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"println(\"Particle p1 has energy=$(p1.energy)\")\nprintln(\"Particle p2 has energy=$(p2.energy)\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"You can see the full documentation of the MCParticle type to see all the available properties by executing the command ?MCParticle or using the @doc macro as follows:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"@doc MCParticle","category":"page"},{"location":"tutorial_edm/#Modifying-the-properties-of-the-MCParticles","page":"Tutorial (EDM)","title":"Modifying the properties of the MCParticles","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"note: Note that\nEDM4hep data types are immutable, so we can not change the properties of the particles directly. To change the properties of a MCParticle, for example, we need to create a new instance with the desired properties. This can be achieved by using the @set macro that will return a new instance with all untouched attributes plus the modified one.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"For example the following line will raise an error","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"try\n    p1.time = 1.1\ncatch e\n    println(e)\nend","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"To change the time property of the particle p1 we can use the @set macro as follows:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"p1 = @set p1.time = 1.1;\nnothing #hide","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Now we can access the new property","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"println(\"Particle p1 has time = $(p1.time)\")","category":"page"},{"location":"tutorial_edm/#Create-a-tree-of-MCParticles","page":"Tutorial (EDM)","title":"Create a tree of MCParticles","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"We will create a tree of MCParticles by adding daughters and parents to the particles","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"p3 = MCParticle(PDG=1, mass=0.0, momentum=(0.750, -1.569, 32.191), generatorStatus=3)\np3, p1 = add_parent(p3, p1)","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"note: Note that\nThe add_parent function returns new instances with the related MCParticle objects since they have been modified. The same applies to the add_daughter function.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Lets add more particles to the tree","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"p4 = MCParticle(PDG=-2, mass=0.0, momentum=(-3.047, -19.000, -54.629), generatorStatus=3)\np4, p2 = add_parent(p4, p2)\n\np5 = MCParticle(PDG=-24, mass=80.799, momentum=(1.517, -20.68, -20.605), generatorStatus=3)\np5, p1 = add_parent(p5, p1)\np5, p2 = add_parent(p5, p2)\n\np6 = MCParticle(PDG=22, mass=0.0, momentum=(-3.813, 0.113, -1.833), generatorStatus=1)\np6, p1 = add_parent(p6, p1)\np6, p2 = add_parent(p6, p2)\n\np7 = MCParticle(PDG=1, mass=0.0, momentum=(-2.445, 28.816, 6.082), generatorStatus=1)\np7, p5 = add_parent(p7, p5)\n\np8 = MCParticle(PDG=-2, mass=0.0, momentum=(3.962, -49.498, -26.687), generatorStatus=1)\np8, p5 = add_parent(p8, p5)","category":"page"},{"location":"tutorial_edm/#Iterate-over-the-particles","page":"Tutorial (EDM)","title":"Iterate over the particles","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Now that we have constructed the tree in memory, we can iterate over the particles, daughters and parents The function getEDCollection returns the collection of particles (EDCollection{MCParticle}). The one-to-many relations are stored in the daughters and parents properties of the MCParticle type. They can be iterated as follows:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"for p in getEDCollection(MCParticle)\n    println(\"MCParticle $(p.index) with PDG=$(p.PDG) and momentum $(p.momentum) has $(length(p.daughters)) daughters\")\n    for d in p.daughters\n        println(\"   ---> $(d.index) with PDG=$(d.PDG) and momentum $(d.momentum)\")\n    end\nend","category":"page"},{"location":"tutorial_edm/#One-to-one-relations","page":"Tutorial (EDM)","title":"One-to-one relations","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The type SimTrackerHit has a one-to-one relation with the type MCParticle. Lets create a hit and associate it to a particle in the tree. We use the keyword argument particle to associate the hit to the particle, like this:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"hit = SimTrackerHit(cellID=0xabadcaffee, eDep=0.1, position=(0.0, 0.0, 0.0), particle=p7);\nnothing #hide","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"note: Note that\nThe just created hit is not yet registered to any collection. This is seen by the value of the index attribute.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"println(\"index=$(hit.index)\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The value #0 indicates that is not registered. To register it, we can use the function register to the default EDCollection","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"nhit = register(hit)\nprintln(\"index=$(nhit.index)\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Now the hit is registered and can be accessed by the getEDCollection function","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"for h in getEDCollection(SimTrackerHit)\n    println(\"SimTrackerHit in cellID=$(string(h.cellID, base=16)) with eDep=$(h.eDep) and position=$(h.position) associated to particle $(h.particle.index)\")\nend","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Alternatively, instead of using the register function, we can also use the function push! to a specific EDCollection.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"hitcollection = EDCollection{SimTrackerHit}()\npush!(hitcollection, hit)\npush!(hitcollection, hit)\nfor h in hitcollection\n    println(\"SimTrackerHit in cellID=$(string(h.cellID, base=16)) with eDep=$(h.eDep) and position=$(h.position) associated to particle $(h.particle.index)\")\nend","category":"page"},{"location":"tutorial_edm/#One-to-many-relations","page":"Tutorial (EDM)","title":"One-to-many relations","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The type Track has a one-to-many relation with objects of type TrackerHit that have created the Track. The Track type has a trackerHits property that behaves as a vector of TrackerHit objects. Functions pushToTrackerHits and popFromTrackerHits are provided to create the relation between the Track and the TrackerHit.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"t_hit1 = TrackerHit3D(cellID=0x1, eDep=0.1, position=(1., 1., 1.))\nt_hit2 = TrackerHit3D(cellID=0x1, eDep=0.2, position=(2., 2., 2.))\ntrack = Track()\ntrack = pushToTrackerHits(track, t_hit1)\ntrack = pushToTrackerHits(track, t_hit2)\nprintln(\"Track has $(length(track.trackerHits)) hits\")\nfor h in track.trackerHits\n   println(\"TrackerHit in cellID=$(string(h.cellID, base=16)) with eDep=$(h.eDep) and position=$(h.position)\")\nend","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The Track object has a trackerHits property that can be iterated and index of TrackerHit3D objects.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"println(\"Hit 1: $(track.trackerHits[1])\")\nprintln(\"Hit 2: $(track.trackerHits[2])\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"We can remove the hits from the track using the popFromTrackerHits function","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"track = popFromTrackerHits(track)\nfor h in track.trackerHits\n    println(\"TrackerHit in cellID=$(string(h.cellID, base=16)) with eDep=$(h.eDep) and position=$(h.position)\")\n end\nprintln(\"After pop Track has $(length(track.trackerHits)) hits\")","category":"page"},{"location":"tutorial_edm/#Convert-PYTHIA-event-to-MCParticles","page":"Tutorial (EDM)","title":"Convert PYTHIA event to MCParticles","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Next we will generate a PYTHIA event and convert it to MCParticles and use the interface provided by EDM4hep to navigate through the particles.","category":"page"},{"location":"tutorial_edm/#Conversion-function-of-PYTHIA-event-to-MCParticles","page":"Tutorial (EDM)","title":"Conversion function of PYTHIA event to MCParticles","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"The following function convertToEDM takes a PYTHIA8.Event object and converts it to a collection of MCParticle objects. The properties of a PYTHIA Particle are mapped to the properties of a MCParticle object. The only complexity is to create the relations between the particles. The function add_parent is used to create the relations between the particles. The interpretation of the indices is described in the PYTHIA documentation:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"There are six allowed combinations of mother1 and mother2:","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"mother1 = mother2 = 0: for lines 0 - 2, where line 0 represents the event as a whole, and 1 and 2 the two incoming beam particles;\nmother1 = mother2 > 0: the particle is a \"carbon copy\" of its mother, but with changed momentum as a \"recoil\" effect, e.g. in a shower;\nmother1 > 0, mother2 = 0: the \"normal\" mother case, where it is meaningful to speak of one single mother to several products, in a shower or decay;\nmother1 < mother2, both > 0, for abs(status) = 81 - 86: primary hadrons produced from the fragmentation of a string spanning the range from mother1 to mother2, so that all partons in this range should be considered mothers; and analogously for abs(status) = 101 - 106, the formation of R-hadrons;\nmother1 < mother2, both > 0, except case 4: particles with two truly different mothers, in particular the particles emerging from a hard 2 → n interaction.\nmother2 < mother1, both > 0: particles with two truly different mothers, notably for the special case that two nearby partons are joined together into a status 73 or 74 new parton, in the g + q → q case the q is made first mother to simplify flavour tracing.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Note that indices in the PYTHIA8.Event start at 0, while in the EDM4hep types start at 1.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"function convertToEDM(event, onlyFinal=false)\n    # Initialize the MCParticle collection\n    mcps = getEDCollection(MCParticle) |> empty!\n    # Loop over the particles in the Pythia event\n    for p in event\n        onlyFinal && (p |> isFinal || continue)\n        # Create a new EDM particle\n        MCParticle(PDG = p |> id,\n                   generatorStatus = p |> status,\n                   charge = p |> charge,\n                   time = p |> tProd,\n                   mass = p |> m,\n                   vertex = Vector3d(p |> xProd, p |> yProd, p |> zProd),\n                   momentum = Vector3d(p |> px, p |> py, p |> pz),\n                   colorFlow = (p |> col, p|> acol)) |> register\n    end\n    onlyFinal && return mcps\n    # Loop over the particles in the Pythia event to create the relations (second pass)\n    for (i,p) in enumerate(event)\n        mcp = mcps[i]\n        m1, m2 = p |> mother1, p |> mother2\n        m1 == m2 > 0 &&  add_parent(mcp, mcps[m1+1])\n        m1 > 0 && m2 == 0 && add_parent(mcp, mcps[m1+1])\n        if 0 < m1 < m2\n            for j in m1:m2\n                add_parent(mcp, mcps[j+1])\n            end\n        end\n    end\n    return mcps\nend","category":"page"},{"location":"tutorial_edm/#Generate-a-PYTHIA-event","page":"Tutorial (EDM)","title":"Generate a PYTHIA event","text":"","category":"section"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"pythia = PYTHIA8.Pythia(\"\", false) # Create a PYTHIA object (mode=0, no output)\npythia << \"Beams:eCM = 8000.\" <<\n          \"HardQCD:all = on\" <<\n          \"PhaseSpace:pTHatMin = 20.\";\n# The purpose of the next two lines is to reduce the amount of output during the event generation\npythia << \"Next:numberShowEvent = 0\" <<\n          \"Next:numberShowProcess = 0\";\npythia |> init\npythia |> next","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"We convert now the PYTHIA event to MCParticles (only final particles in this case)","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"mcps = convertToEDM(event(pythia), true);\nnothing #hide","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Lets's see if the conversion was successful and the set of particles conserves the energy, charge and momentum","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"println(\"Total energy = $(sum(p.energy for p in mcps))\")\nprintln(\"Total charge = $(sum(mcps.charge))\")\nprintln(\"Total momentum = $(sum(mcps.momentum))\")","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"We recover here ths center-of-mass energy, the total charge of 2 from the incident protons and the total momentum of the event (compatible with zero).","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Lets now display some selected decay trees inside the full MCParticle collection. We start by converting the PYTHIA event taking all particles this time. The, we implement a recursive function printdecayto print the decay tree of the particles.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"mcps = convertToEDM(event(pythia));\nfunction printdecay(indent, p)\n    println(isempty(indent) ? \"\" : indent*\"---> \", \"$(p.name) E=$(p.energy)\")\n    for d in p.daughters\n        printdecay(indent*\"   \", d)\n    end\nend","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"Lets use the function to print the decay trees of all the particles in the event that contains the charm quark. The module Corpuscles is used to identify the charm quark.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"for p in mcps\n    hascharm(p.PDG) || continue\n    printdecay(\"\", p)\nend","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"In another event we get obviously a different set of particles and decay trees.","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"pythia |> next\nmcps = convertToEDM(event(pythia));\nfor p in mcps\n    hascharm(p.PDG) || continue\n    printdecay(\"\", p)\nend","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"","category":"page"},{"location":"tutorial_edm/","page":"Tutorial (EDM)","title":"Tutorial (EDM)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"EditURL = \"tutorial_io_lit.jl\"","category":"page"},{"location":"tutorial_io/#EDM4hep.jl-EDM-I/O-Tutorial","page":"Tutorial (I/O)","title":"EDM4hep.jl EDM I/O Tutorial","text":"","category":"section"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"This tutorial shows how to read EDM4hep data files and perform some simple analysis","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"note: Note that\nYou can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial_io/#Table-of-contents","page":"Tutorial (I/O)","title":"Table of contents","text":"","category":"section"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"Pages = [\"tutorial_io.md\"]\nDepth = 2:3","category":"page"},{"location":"tutorial_io/#Loading-the-necessary-modules","page":"Tutorial (I/O)","title":"Loading the necessary modules","text":"","category":"section"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"We will use the EDM4hep module that defines all the EDM4hep types and its relations and links.\nWe will use the FHist module to create histograms\nWe will use the Plots module to plot the histograms","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"If these modules are not installed, you can install them by running the following commands:","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"using Pkg\nPkg.add(\"EDM4hep\")\nPkg.add(\"FHist\")\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"using EDM4hep\nusing EDM4hep.RootIO\nusing Base.Iterators: partition, take\nusing FHist\nusing Plots: plot, scatter, plot!, theme","category":"page"},{"location":"tutorial_io/#Reading-an-EDM4hep-file","page":"Tutorial (I/O)","title":"Reading an EDM4hep file","text":"","category":"section"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"We will read an EDM4hep file with the RootIO.Reader function. This function returns a reader object that can be used to access the events in the file. The input file is a ROOT file with the EDM4hep data model and is located to the path ttbar_edm4hep_digi.root.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"finput = joinpath(@__DIR__,\"../../examples\" ,\"ttbar_edm4hep_digi.root\")","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"We create a reader object to access the events in the file. The object displays a summary table of the content of the file.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"reader = RootIO.Reader(finput)","category":"page"},{"location":"tutorial_io/#Accessing-the-events","page":"Tutorial (I/O)","title":"Accessing the events","text":"","category":"section"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The TTree called events contains the events in the file. We can access the events by using the RootIO.get function with the reader object and the name of the TTree.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"events = RootIO.get(reader, \"events\");\nnothing #hide","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"note: Note that\nIf you get warnings is because there is a mismatch between the current schema version of EDM4hep and version when the file was written. The default behavior is ignore old types and set to zero the attributes that do not exists in the file.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"We can access the first event in the file by using the index 1 in the events array.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"evt = events[1];\nnothing #hide","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"the evt object is a UnROOT.LazyEvent. Each leaf (column) can be accessed directlyt if you know the name of the leaf. Typically the name is of the form <collection_name>_<field_name>. The full list of names can be obtained by calling the names function on the events object. For example:","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"for n in names(events) |> sort!\n    startswith(n, \"ECalBarrelCollection\") && println(n)\nend","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"note: Note that\nThere is not need to access individual columns like this. The RootIO.get function can be used to access the collections directly.","category":"page"},{"location":"tutorial_io/#Accessing-the-collections","page":"Tutorial (I/O)","title":"Accessing the collections","text":"","category":"section"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The available collections in the event can be obtained by displaying the reader object.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"show(reader)","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The RootIO.get function can be used to access the collections in the event. The function takes the reader object, the event object and the name of the collection as arguments.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"calo = RootIO.get(reader, evt, \"AllCaloHitContributionsCombined\");\nhits = RootIO.get(reader, evt, \"ECalBarrelCollection\");\nmcps = RootIO.get(reader, evt, \"MCParticle\");\nnothing #hide","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"note: Note that\nRelationships will automatically be setup if the related collections will be also be accessed. For example, in this case the relation of SimCalorimeterHits from the collection ECalBarrelCollection to CaloHitContributions from AllCaloHitContributionsCombined will be filled.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The calo object is a EDM4hep.EDCollection object that contains the calorimeter hit contributions. The hits object is a EDM4hep.EDCollection object that contains the hits in the ECal barrel. The mcps object is a EDM4hep.EDCollection object that contains the MCParticles.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"We can now print some information about the collections.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"for hit in take(hits, 20)\n    println(\"ECAL Hit $(hit.index) has energy $(hit.energy) at position $(hit.position) with $(length(hit.contributions)) contributions\")\nend","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"Lets check whether the total energy in the hits is the same as the sum of all the calorimeter contributions. This an example to show the expressivity of the Julia language. We can construct a StructArray with all the related hit contributions and use the sum function to sum the energy of all the contributions as a column of the constructed SoA.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"for hit in hits\n    StructArray(hit.contributions).energy |> sum |> c -> c ≈ hit.energy || println(\"Hit $(hit.index) has energy $(hit.energy) and contributions $(c)\")\nend","category":"page"},{"location":"tutorial_io/#Drawing-the-EDMM4hep-data","page":"Tutorial (I/O)","title":"Drawing the EDMM4hep data","text":"","category":"section"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The following shows how easy is to draw EDM4hep event using the Plots module. In this example we want to plot the calorimeter hits in the space with dots with the size proportional to the energy of the hit.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"maxE = hits.energy |> maximum\nscatter(hits.position.x, hits.position.y, hits.position.z,\n        markersize = (hits.energy/maxE)*10, color = :blue)","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The projection in the X-Y plane is shown below.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"scatter(hits.position.x, hits.position.y, markersize = (hits.energy/maxE)*10, color = :blue)","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"Accessing the hit attributes as columns of the hits object is very efficient. Lets verify it. Using the @btime macro from the BenchmarkTools module we can measure the time to access the energy column.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"using BenchmarkTools\n@benchmark hits.energy |> maximum","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The time to access the energy column is very small.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"@benchmark begin\n    _max = 0.0f0\n    for h in hits\n        _max = max(_max, h.energy)\n    end\n    _max\nend","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"The time to access the energy column using a loop is much larger.","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"","category":"page"},{"location":"tutorial_io/","page":"Tutorial (I/O)","title":"Tutorial (I/O)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#EDM4hep-in-Julia","page":"Introduction","title":"EDM4hep in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Prototype of the EDM4hep (generic Event Data Model for HEP experiments part of Key4hep) for Julia with the goal to have very simple structures (isbits) with the purpose to evaluate its ergonomic design and implementation performance.","category":"page"},{"location":"#PODIO-generation","page":"Introduction","title":"PODIO generation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Julia POD structs should be generated from the edm4hep.yaml yaml file using PODIO scripts.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For the time being, for this evaluation, the Julia structs are generated by a local Julia script in ./podio/generate.jl. The files genComponents/jl and genDatatypes.jl are fully generated. ","category":"page"},{"location":"#Main-design-features","page":"Introduction","title":"Main design features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"All EDM4hep entities are immutable structs and containing basic types and structs. Including the relationships (one-to-one and one-to-many) and vector members. Objects attributes cannot be changed. This makes the objects with the isbits(obj) == true.\nObjects are created by default not being registered, they are free floating. The user can register them with register(obj).\nNote that operations like register, setting  relationships (add_daughter,...), etc. will automatically create a new instance. The typical pattern is to overwrite the user variable with the new instance, e.g.:\np1 = MCParticle(...)\np1 = register(p1)\np1, d1 = add_daughter(p1, MCParticle(...))\nThe main goal for reading EDM4hep containers from a ROOT file is to obtain as result a StructArray(see StructArrays.jl documentation). This provides a very efficient access by column and the same time provide a convenient views as object instances. For example if you want to sum the momentum of a range of MCParticles the user should be able to write:\njulia> mcparticles = get(reader,...)\njulia> mcparticles[5:8].momentum\n4-element StructArray(::Vector{Float32}, ::Vector{Float32}, ::Vector{Float32}) with eltype Vector3f:\n  (0.8740664,-0.002116337,124.84335)\n  (0.8602309,-0.056633994,-124.632545)\n  (-0.00012483617,0.0021162117,0.0026654897)\n  (0.014539731,0.05663412,-0.32755017)\n\njulia> sum(mcparticles[5:8].momentum)\n  (1.7487122,0.0,-0.11407688)","category":"page"},{"location":"#Roadmap","page":"Introduction","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are a number of issues and problems still to be resolved. We keep track of them in this list:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Need to generate and support VectorMembers. For the time being are ignored. - DONE\nHandle cyclic datatype dependencies. In EDM4hep there is one case that is not yet resolved. Vertex depends on ReconstructedParticle in a one-to-one relation and ReconstructedParticle relates to Vertex. Using the abstract class POD in this case works well to break the cycle. - DONE \nBetter handle collectionID in one-to-many relations - DONE\nBe able to read RNTuple files in addition to TTree files - DONE\nGenerate doc string with member information - DONE\nGenerate accessors for one-to-many relations, vector members - DONE \nSupport latest version (RC2) of RNTuple format - DONE\nSupport for multi-threading (i.e. be able to add @threads in the event loop) - DONE","category":"page"},{"location":"#Tests","page":"Introduction","title":"Tests","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Unit tests can be run with julia --project=. test/runtests.jl","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"#examples/mcparticle_tree.jl","page":"Introduction","title":"examples/mcparticle_tree.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Creates a collection of MCParticles and a collection of SimTrackerHits in memory, constructing the relations between particle parents and daughters, as well as, the one-to-one relation between each simulation hit and its originating MCParticle.","category":"page"},{"location":"#examples/read_example.jl","page":"Introduction","title":"examples/read_example.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An example of reading from a ROOT file created by the C++ implementation of EDM4hep. This is the full code:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using EDM4hep\nusing EDM4hep.RootIO\n\ncd(@__DIR__)\nf = \"ttbar_edm4hep_digi.root\"\n\nreader = RootIO.Reader(f)\nevents = RootIO.get(reader, \"events\")\n\nevt = events[1];\n\nhits = RootIO.get(reader, evt, \"InnerTrackerBarrelCollection\")\nmcps = RootIO.get(reader, evt, \"MCParticle\")\n\nfor hit in hits\n    println(\"Hit $(hit.index) is related to MCParticle $(hit.mcparticle.index) with name $(hit.mcparticle.name)\")\nend\n\nfor p in mcps\n    println(\"MCParticle $(p.index) $(p.name) with momentum $(p.momentum) and energy $(p.energy) has $(length(p.daughters)) daughters\")\n    for d in p.daughters\n        println(\"   ---> $(d.index) $(d.name) and momentum $(d.momentum) has $(length(d.parents)) parents\")\n        for m in d.parents\n            println(\"      ---> $(m.index) $(m.name)\")\n        end \n    end\nend","category":"page"},{"location":"#examples/FCC/analysis_mH-recoil.jl","page":"Introduction","title":"examples/FCC/analysis_mH-recoil.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is basically the example higgs/mH-recoil/mumu from FCCAnalyses. It shows in a realistic manner how to develop analysis functions using the Data Types from EDM4hep to created high-level analysis functions.  The Jupyter notebook analysis_mH-recoil.ipynb shows the same example in form of a notebook. ","category":"page"},{"location":"#examples/FCC/analysis_MT.jl","page":"Introduction","title":"examples/FCC/analysis_MT.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is basically the example higgs/mH-recoil/mumu from FCCAnalyses in a multi-threaded mode.  The Jupyter notebook analysis_mH-recoil.ipynb shows the same example in form of a notebook. ","category":"page"},{"location":"#EDM4hep-Data-Model","page":"Introduction","title":"EDM4hep Data Model","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the diagram for the EDM4hep datamodel including relationships. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Figure)","category":"page"}]
}
